// 문제 설명
// 휴대폰의 자판은 컴퓨터 키보드 자판과는 다르게 하나의 키에 여러 개의 문자가 할당될 수 있습니다. 키 하나에 여러 문자가 할당된 경우, 동일한 키를 연속해서 빠르게 누르면 할당된 순서대로 문자가 바뀝니다.

// 예를 들어, 1번 키에 "A", "B", "C" 순서대로 문자가 할당되어 있다면 1번 키를 한 번 누르면 "A", 두 번 누르면 "B", 세 번 누르면 "C"가 되는 식입니다.

// 같은 규칙을 적용해 아무렇게나 만든 휴대폰 자판이 있습니다. 이 휴대폰 자판은 키의 개수가 1개부터 최대 100개까지 있을 수 있으며, 특정 키를 눌렀을 때 입력되는 문자들도 무작위로 배열되어 있습니다. 또, 같은 문자가 자판 전체에 여러 번 할당된 경우도 있고, 키 하나에 같은 문자가 여러 번 할당된 경우도 있습니다. 심지어 아예 할당되지 않은 경우도 있습니다. 따라서 몇몇 문자열은 작성할 수 없을 수도 있습니다.

// 이 휴대폰 자판을 이용해 특정 문자열을 작성할 때, 키를 최소 몇 번 눌러야 그 문자열을 작성할 수 있는지 알아보고자 합니다.

// 1번 키부터 차례대로 할당된 문자들이 순서대로 담긴 문자열배열 keymap과 입력하려는 문자열들이 담긴 문자열 배열 targets가 주어질 때, 각 문자열을 작성하기 위해 키를 최소 몇 번씩 눌러야 하는지 순서대로 배열에 담아 return 하는 solution 함수를 완성해 주세요.

// 단, 목표 문자열을 작성할 수 없을 때는 -1을 저장합니다.

// 제한사항
// 1 ≤ keymap의 길이 ≤ 100
// 1 ≤ keymap의 원소의 길이 ≤ 100
// keymap[i]는 i + 1번 키를 눌렀을 때 순서대로 바뀌는 문자를 의미합니다.
// 예를 들어 keymap[0] = "ABACD" 인 경우 1번 키를 한 번 누르면 A, 두 번 누르면 B, 세 번 누르면 A 가 됩니다.
// keymap의 원소의 길이는 서로 다를 수 있습니다.
// keymap의 원소는 알파벳 대문자로만 이루어져 있습니다.
// 1 ≤ targets의 길이 ≤ 100
// 1 ≤ targets의 원소의 길이 ≤ 100
// targets의 원소는 알파벳 대문자로만 이루어져 있습니다.
// 입출력 예
// keymap	targets	result
// ["ABACD", "BCEFD"]	["ABCD","AABB"]	[9, 4]
// ["AA"]	["B"]	[-1]
// ["AGZ", "BSSS"]	["ASA","BGZ"]	[4, 6]
// 입출력 예 설명
// 입출력 예 #1

// "ABCD"의 경우,
// 1번 키 한 번 → A
// 2번 키 한 번 → B
// 2번 키 두 번 → C
// 1번 키 다섯 번 → D
// 따라서 총합인 9를 첫 번째 인덱스에 저장합니다.
// "AABB"의 경우,
// 1번 키 한 번 → A
// 1번 키 한 번 → A
// 2번 키 한 번 → B
// 2번 키 한 번 → B
// 따라서 총합인 4를 두 번째 인덱스에 저장합니다.
// 결과적으로 [9,4]를 return 합니다.
// 입출력 예 #2

// "B"의 경우, 'B'가 어디에도 존재하지 않기 때문에 -1을 첫 번째 인덱스에 저장합니다.
// 결과적으로 [-1]을 return 합니다.
// 입출력 예 #3

// "ASA"의 경우,
// 1번 키 한 번 → A
// 2번 키 두 번 → S
// 1번 키 한 번 → A
// 따라서 총합인 4를 첫 번째 인덱스에 저장합니다.
// "BGZ"의 경우,
// 2번 키 한 번 → B
// 1번 키 두 번 → G
// 1번 키 세 번 → Z
// 따라서 총합인 6을 두 번째 인덱스에 저장합니다.
// 결과적으로 [4, 6]을 return 합니다.

// 처음 이 문제를 보고,
// keymap에 저장된 key들을 obj에 저장하여 탐색하면
// 이중반복문 없이 할 수 있다고 생각했지만,
// keymap[i].length 가 최대 100인 것을 감안하면
// 이중 반복문이 허용된다는 것을 알았다.

// 따라서 코드 구성은

// 1. 먼저 keymap에 들어있는 키가 몇번 눌러야 입력되는지 obj에 저장한다.
// 2. 만약 이미 저장된 키가 있다면, 저장값을 현재 탐색중인 인덱스와 비교하여 둘 중 덜 누를 수 있는 값을 저장한다.
// 3. 저장이 완료되면, targets[i]를 탐색하여 값을 더한다.
// 4. 만약 obj[targets[i]]의 값이 없다면, -1을 저장한다.

// 라는 구성으로 생각하게 되었다.
// 해당 수도코드를 기반으로 짠 코드는,

function solution(keymap, targets) {
  var answer = []; //리턴할 배열
  let kObj = {}; // 각 key를 입력하기 위해 몇번 눌러야하는 지 저장할 obj
  for(let key of keymap){
      for(let i = 0; i < key.length; i++){ //keymap 탐색
          if(!kObj[key[i]] || kObj[key[i]] > i){ 
            // 만약 현재 저장된 key값이 없거나, 저장값이 현재 인덱스값보다 클 경우(지금 눌러야하는 것보다 더 많이 눌러야 할 경우)
              kObj[key[i]] = i + 1; //obj에 저장
          }
      }
  }
  
  for(let t of targets){ // targets 탐색
      let curNum = 0; // 현재 target이 몇번 눌러야 완성이 가능한 지 저장하기 위한 변수
      for(let i = 0; i < t.length; i++){
          curNum += kObj[t[i]]; // 현재 target을 탐색하여 obj에 저장된 값을 가져와 curNum에 더한다.
      }
      if(!curNum){ // 모든 과정을 마치고 만약 curNum에 '자연수 + undefined' 수식을 통해 NaN값이 저장되어 있을 경우
          curNum = -1; // -1 저장
      }
      answer.push(curNum)
  }
  
  return answer;
}

// 처음엔 keymap[i]값을 모두 묶어 진행하면 이중 반복문 처리 없이 할 수 있을 것이라고 가볍게 생각했으나,
// 어차피 keymap[i][j]값을 비교해야 하는 것이기에, 이중반복문 처리가 불가피했다.
// 이중반복문 처리에서 reduce를 통해 짧게 처리할 수 있었으나,
// 개인적으로 고차함수를 사용하는 것보다 for을 사용하는 것이 코드 진행에 대한 가독성이 더 좋다고 생각한다.
// 함께 일하는 사람마다 추구하는 바가 다르겠다만, 두 가지 방법을 사용할 수 있다는 것에 감사하고 넘어가자.